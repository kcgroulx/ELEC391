%% Fresh Position PID controller simulation
clear; clc;
clear fresh_position_pid;

%% Simulation parameters
dt = 0.001;             % 1 kHz loop timing
steps = 6000;           % 6 s total runtime
time = (0:steps-1) * dt;

%% Simple motor/MBK plant (units: meters)
mass = 3.0;     % kg
damping = 0.5;  % viscous damping
stiffness = 0.1;
command_gain = 25; % scale normalized PWM to torque/force units

%% Trajectory: single-step target (in meters)
target_position = ones(1, steps) * 0.040;

%% Logs
position = zeros(1, steps);
velocity = zeros(1, steps);
measured_position = zeros(1, steps);
control = zeros(1, steps);
error_log = zeros(1, steps);

%% Simulation loop
for i = 1:steps
    measured_position(i) = position(i);      % assume ideal encoder
    command = fresh_position_pid(target_position(i), measured_position(i), dt);
    control(i) = command;
    error_log(i) = target_position(i) - measured_position(i);

    if i < steps
        acceleration = (command * command_gain - damping * velocity(i) - stiffness * position(i)) / mass;
        velocity(i + 1) = velocity(i) + acceleration * dt;
        position(i + 1) = position(i) + velocity(i + 1) * dt;
    end
end

%% Plot results
figure;
subplot(3,1,1);
plot(time, position, 'b', time, target_position, 'r--');
ylabel('Position (m)');
legend('Actual', 'Target');
grid on;

subplot(3,1,2);
plot(time, control);
ylabel('Command');
grid on;

subplot(3,1,3);
plot(time, error_log);
ylabel('Error (deg)');
xlabel('Time (s)');
grid on;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Local functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function command = fresh_position_pid(target_pos, measured_pos, dt)
    % Controller gains and limits match the firmware design (converted to meters)
    persistent kp ki kd output_limit deadband_pos i_zone_pos integrator_limit;
    persistent max_command_step min_effective_command d_lpf_alpha;
    persistent integrator prev_pos d_filtered prev_command first_call;

    if isempty(first_call)
        kp = 0.0065;          % gentler approach for steady convergence
        ki = 0.027;
        kd = 0.018;
        output_limit = 1.0;
        deadband_pos = 0.001;
        i_zone_pos = 0.08;
        integrator_limit = 30.0;
        max_command_step = 0.02;
        min_effective_command = 0.8;
        d_lpf_alpha = 0.15;
        integrator = 0.0;
        prev_pos = measured_pos;
        d_filtered = 0.0;
        prev_command = 0.0;
        first_call = true;
    end

    error = target_pos - measured_pos;
    abs_error = abs(error);

    % Derivative on measurement with simple LPF
    angle_rate = (measured_pos - prev_pos) / dt;
    prev_pos = measured_pos;
    d_filtered = d_filtered + d_lpf_alpha * (angle_rate - d_filtered);

    % Deadband and integrator reset
    if abs_error <= deadband_pos
        integrator = 0.0;
        prev_command = 0.0;
        command = 0.0;
        return;
    end

    % Integrate only when inside i-zone to avoid windup
    if abs_error <= i_zone_pos
        integrator = integrator + error * dt;
        integrator = clampf(integrator, -integrator_limit, integrator_limit);
    else
        integrator = 0.0;
    end

    p_term = kp * error;
    i_term = ki * integrator;
    d_term = -kd * d_filtered;

    u = p_term + i_term + d_term;
    u = clampf(u, -output_limit, output_limit);

    % Slew-rate limit the command output
    du = clampf(u - prev_command, -max_command_step, max_command_step);
    command = prev_command + du;

    % Guarantee minimum effective command to overcome static friction
    if command > 0 && command < min_effective_command
        command = min_effective_command;
    elseif command < 0 && command > -min_effective_command
        command = -min_effective_command;
    end

    prev_command = command;
end

function y = clampf(x, lo, hi)
    y = min(max(x, lo), hi);
end
